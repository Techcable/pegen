#!/usr/bin/env janet
# @generated by pegen from pegen/metagrammar_janet.gram

(use pegen/parser/helpers)
(use pegen/grammar)

# Keywords and soft keywords are listed at the end of the parser definition.
(defparser GeneratedParser

    (decorated-defn [@memoize] start [self]
        # start: grammar $
        (var mark (:_mark self))
        (when (and 
            (var grammar (self grammar))
            (var _endmarker (self expect "ENDMARKER"))
        )
            (return grammar)
        (:_reset self mark)
        (return None)
    )

    (decorated-defn [@memoize] grammar [self]
        # grammar: metas rules | rules
        (var mark (:_mark self))
        (when (and 
            (var metas (self metas))
            (var rules (self rules))
        )
            (return ( make - grammar rules metas ))
        (:_reset self mark)
        (when (and 
            (var rules (self rules))
        )
            (return ( make - grammar rules [] ))
        (:_reset self mark)
        (return None)
    )

    (decorated-defn [@memoize] metas [self]
        # metas: meta metas | meta
        (var mark (:_mark self))
        (when (and 
            (var meta (self meta))
            (var metas (self metas))
        )
            (return [meta] + metas)
        (:_reset self mark)
        (when (and 
            (var meta (self meta))
        )
            (return [meta])
        (:_reset self mark)
        (return None)
    )

    (decorated-defn [@memoize] meta [self]
        # meta: "@" NAME NEWLINE | "@" NAME NAME NEWLINE | "@" NAME STRING NEWLINE
        (var mark (:_mark self))
        (when (and 
            (var literal (expect `"@"`))
            (var name (self name))
            (var _newline (self expect "NEWLINE"))
        )
            (return [( name : string ) nil])
        (:_reset self mark)
        (when (and 
            (var literal (expect `"@"`))
            (var a (self name))
            (var b (self name))
            (var _newline (self expect "NEWLINE"))
        )
            (return [( a : string ) ( b : string )])
        (:_reset self mark)
        (when (and 
            (var literal (expect `"@"`))
            (var name (self name))
            (var string (self string))
            (var _newline (self expect "NEWLINE"))
        )
            (return [( name : string ) ( parse ( string : string ) )])
        (:_reset self mark)
        (return None)
    )

    (decorated-defn [@memoize] rules [self]
        # rules: rule rules | rule
        (var mark (:_mark self))
        (when (and 
            (var rule (self rule))
            (var rules (self rules))
        )
            (return [rule ; rules])
        (:_reset self mark)
        (when (and 
            (var rule (self rule))
        )
            (return [rule])
        (:_reset self mark)
        (return None)
    )

    (decorated-defn [@memoize] rule [self]
        # rule: rulename memoflag? ":" alts NEWLINE INDENT more_alts DEDENT | rulename memoflag? ":" NEWLINE INDENT more_alts DEDENT | rulename memoflag? ":" alts NEWLINE
        (var mark (:_mark self))
        (when (and 
            (var rulename (self rulename))
            (var opt (self memoflag),)
            (var literal (expect `":"`))
            (var alts (self alts))
            (var _newline (self expect "NEWLINE"))
            (var _indent (self expect "INDENT"))
            (var more_alts (self more_alts))
            (var _dedent (self expect "DEDENT"))
        )
            (return ( make - rule ; ( slice rulename 0 2 ) ( make - rhs ( + ( alts : alts ) ( more_alts : alts ) ) ) : memo opt ))
        (:_reset self mark)
        (when (and 
            (var rulename (self rulename))
            (var opt (self memoflag),)
            (var literal (expect `":"`))
            (var _newline (self expect "NEWLINE"))
            (var _indent (self expect "INDENT"))
            (var more_alts (self more_alts))
            (var _dedent (self expect "DEDENT"))
        )
            (return ( make - rule ; ( slice rulename 0 2 ) more_alts : memo opt ))
        (:_reset self mark)
        (when (and 
            (var rulename (self rulename))
            (var opt (self memoflag),)
            (var literal (expect `":"`))
            (var alts (self alts))
            (var _newline (self expect "NEWLINE"))
        )
            (return ( make - rule ; ( slice rulename 0 2 ) alts : memo opt ))
        (:_reset self mark)
        (return None)
    )

    (decorated-defn [@memoize] rulename [self]
        # rulename: NAME annotation | NAME
        (var mark (:_mark self))
        (when (and 
            (var name (self name))
            (var annotation (self annotation))
        )
            (return [( name : string ) annotation])
        (:_reset self mark)
        (when (and 
            (var name (self name))
        )
            (return [( name : string ) nil])
        (:_reset self mark)
        (return None)
    )

    (decorated-defn [@memoize] memoflag [self]
        # memoflag: '(' "memo" ')'
        (var mark (:_mark self))
        (when (and 
            (var literal (expect "'('"))
            (var literal_1 (expect `"memo"`))
            (var literal_2 (expect "')'"))
        )
            (return "memo")
        (:_reset self mark)
        (return None)
    )

    (decorated-defn [@memoize] alts [self]
        # alts: alt "|" alts | alt
        (var mark (:_mark self))
        (when (and 
            (var alt (self alt))
            (var literal (expect `"|"`))
            (var alts (self alts))
        )
            (return ( make - rhs [alt ; ( alts : alts )] ))
        (:_reset self mark)
        (when (and 
            (var alt (self alt))
        )
            (return ( make - rhs [alt] ))
        (:_reset self mark)
        (return None)
    )

    (decorated-defn [@memoize] more_alts [self]
        # more_alts: "|" alts NEWLINE more_alts | "|" alts NEWLINE
        (var mark (:_mark self))
        (when (and 
            (var literal (expect `"|"`))
            (var alts (self alts))
            (var _newline (self expect "NEWLINE"))
            (var more_alts (self more_alts))
        )
            (return ( make - rhs [; ( alts : alts ) ; ( more_alts : alts )] ))
        (:_reset self mark)
        (when (and 
            (var literal (expect `"|"`))
            (var alts (self alts))
            (var _newline (self expect "NEWLINE"))
        )
            (return ( make - rhs ( alts : alts ) ))
        (:_reset self mark)
        (return None)
    )

    (decorated-defn [@memoize] alt [self]
        # alt: items '$' action | items '$' | items action | items
        (var mark (:_mark self))
        (when (and 
            (var items (self items))
            (var literal (expect "'$'"))
            (var action (self action))
        )
            (return ( make - alt [; items ( make - named - item nil ( make - name - leaf "ENDMARKER" ) )] : action action ))
        (:_reset self mark)
        (when (and 
            (var items (self items))
            (var literal (expect "'$'"))
        )
            (return ( make - alt [; items ( make - named - item nil ( make - name - leaf "ENDMARKER" ) )] : action nil ))
        (:_reset self mark)
        (when (and 
            (var items (self items))
            (var action (self action))
        )
            (return ( make - alt items : action action ))
        (:_reset self mark)
        (when (and 
            (var items (self items))
        )
            (return ( make - alt items : action nil ))
        (:_reset self mark)
        (return None)
    )

    (decorated-defn [@memoize] items [self]
        # items: named_item items | named_item
        (var mark (:_mark self))
        (when (and 
            (var named_item (self named_item))
            (var items (self items))
        )
            (return [named_item ; items])
        (:_reset self mark)
        (when (and 
            (var named_item (self named_item))
        )
            (return [named_item])
        (:_reset self mark)
        (return None)
    )

    (decorated-defn [@memoize] named_item [self]
        # named_item: NAME annotation '=' ~ item | NAME '=' ~ item | item | forced_atom | lookahead
        (var mark (:_mark self))
        (set cut False)
        (when (and 
            (var name (self name))
            (var annotation (self annotation))
            (var literal (expect "'='"))
            (var cut true)
            (var item (self item))
        )
            (return ( make - named - item ( name : string ) item annotation ))
        (:_reset self mark)
        (when cut (return nil))
        (set cut False)
        (when (and 
            (var name (self name))
            (var literal (expect "'='"))
            (var cut true)
            (var item (self item))
        )
            (return ( make - named - item ( name : string ) item ))
        (:_reset self mark)
        (when cut (return nil))
        (when (and 
            (var item (self item))
        )
            (return ( make - named - item nil item ))
        (:_reset self mark)
        (when (and 
            (var it (self forced_atom))
        )
            (return ( make - named - item nil it ))
        (:_reset self mark)
        (when (and 
            (var it (self lookahead))
        )
            (return ( make - named - item nil it ))
        (:_reset self mark)
        (return None)
    )

    (decorated-defn [@memoize] forced_atom [self]
        # forced_atom: '&' '&' ~ atom
        (var mark (:_mark self))
        (set cut False)
        (when (and 
            (var literal (expect "'&'"))
            (var literal_1 (expect "'&'"))
            (var cut true)
            (var atom (self atom))
        )
            (return ( make - forced atom ))
        (:_reset self mark)
        (when cut (return nil))
        (return None)
    )

    (decorated-defn [@memoize] lookahead [self]
        # lookahead: '&' ~ atom | '!' ~ atom | '~'
        (var mark (:_mark self))
        (set cut False)
        (when (and 
            (var literal (expect "'&'"))
            (var cut true)
            (var atom (self atom))
        )
            (return ( make - positive - lookahead atom ))
        (:_reset self mark)
        (when cut (return nil))
        (set cut False)
        (when (and 
            (var literal (expect "'!'"))
            (var cut true)
            (var atom (self atom))
        )
            (return ( make - negative - lookahead atom ))
        (:_reset self mark)
        (when cut (return nil))
        (when (and 
            (var literal (expect "'~'"))
        )
            (return ( make - cut ))
        (:_reset self mark)
        (return None)
    )

    (decorated-defn [@memoize] item [self]
        # item: '[' ~ alts ']' | atom '?' | atom '*' | atom '+' | atom '.' atom '+' | atom
        (var mark (:_mark self))
        (set cut False)
        (when (and 
            (var literal (expect "'['"))
            (var cut true)
            (var alts (self alts))
            (var literal_1 (expect "']'"))
        )
            (return ( make - opt alts ))
        (:_reset self mark)
        (when cut (return nil))
        (when (and 
            (var atom (self atom))
            (var literal (expect "'?'"))
        )
            (return ( make - opt atom ))
        (:_reset self mark)
        (when (and 
            (var atom (self atom))
            (var literal (expect "'*'"))
        )
            (return ( make - repeat0 atom ))
        (:_reset self mark)
        (when (and 
            (var atom (self atom))
            (var literal (expect "'+'"))
        )
            (return ( make - repeat1 atom ))
        (:_reset self mark)
        (when (and 
            (var sep (self atom))
            (var literal (expect "'.'"))
            (var node (self atom))
            (var literal_1 (expect "'+'"))
        )
            (return ( make - gather sep node ))
        (:_reset self mark)
        (when (and 
            (var atom (self atom))
        )
            (return atom)
        (:_reset self mark)
        (return None)
    )

    (decorated-defn [@memoize] atom [self]
        # atom: '(' ~ alts ')' | NAME | STRING
        (var mark (:_mark self))
        (set cut False)
        (when (and 
            (var literal (expect "'('"))
            (var cut true)
            (var alts (self alts))
            (var literal_1 (expect "')'"))
        )
            (return ( make - group alts ))
        (:_reset self mark)
        (when cut (return nil))
        (when (and 
            (var name (self name))
        )
            (return ( make - name - leaf ( name : string ) ))
        (:_reset self mark)
        (when (and 
            (var string (self string))
        )
            (return ( make - string - leaf ( string : string ) ))
        (:_reset self mark)
        (return None)
    )

    (decorated-defn [@memoize] action [self]
        # action: "{" ~ target_atoms "}"
        (var mark (:_mark self))
        (set cut False)
        (when (and 
            (var literal (expect `"{"`))
            (var cut true)
            (var target_atoms (self target_atoms))
            (var literal_1 (expect `"}"`))
        )
            (return target_atoms)
        (:_reset self mark)
        (when cut (return nil))
        (return None)
    )

    (decorated-defn [@memoize] annotation [self]
        # annotation: "[" ~ target_atoms "]"
        (var mark (:_mark self))
        (set cut False)
        (when (and 
            (var literal (expect `"["`))
            (var cut true)
            (var target_atoms (self target_atoms))
            (var literal_1 (expect `"]"`))
        )
            (return target_atoms)
        (:_reset self mark)
        (when cut (return nil))
        (return None)
    )

    (decorated-defn [@memoize] target_atoms [self]
        # target_atoms: target_atom target_atoms | target_atom
        (var mark (:_mark self))
        (when (and 
            (var target_atom (self target_atom))
            (var target_atoms (self target_atoms))
        )
            (return target_atom + " " + target_atoms)
        (:_reset self mark)
        (when (and 
            (var target_atom (self target_atom))
        )
            (return target_atom)
        (:_reset self mark)
        (return None)
    )

    (decorated-defn [@memoize] target_atom [self]
        # target_atom: "{" ~ target_atoms? "}" | "[" ~ target_atoms? "]" | NAME "*" | NAME | NUMBER | STRING | "?" | ":" | !"}" !"]" OP
        (var mark (:_mark self))
        (set cut False)
        (when (and 
            (var literal (expect `"{"`))
            (var cut true)
            (var atoms (self target_atoms),)
            (var literal_1 (expect `"}"`))
        )
            (return ( string "{" ( if atoms atoms "" ) "}" ))
        (:_reset self mark)
        (when cut (return nil))
        (set cut False)
        (when (and 
            (var literal (expect `"["`))
            (var cut true)
            (var atoms (self target_atoms),)
            (var literal_1 (expect `"]"`))
        )
            (return ( string "[" ( if atoms atoms "" ) "]" ))
        (:_reset self mark)
        (when cut (return nil))
        (when (and 
            (var name (self name))
            (var literal (expect `"*"`))
        )
            (return ( string ( name : string ) "*" ))
        (:_reset self mark)
        (when (and 
            (var name (self name))
        )
            (return ( name : string ))
        (:_reset self mark)
        (when (and 
            (var number (self number))
        )
            (return ( number : string ))
        (:_reset self mark)
        (when (and 
            (var string (self string))
        )
            (return ( string : string ))
        (:_reset self mark)
        (when (and 
            (var literal (expect `"?"`))
        )
            (return "?")
        (:_reset self mark)
        (when (and 
            (var literal (expect `":"`))
        )
            (return ":")
        (:_reset self mark)
        (when (and 
            ((self negative_lookahead  expect `"}"`))
            ((self negative_lookahead  expect `"]"`))
            (var op (self op))
        )
            (return ( op : string ))
        (:_reset self mark)
        (return None)
    )

    (def KEYWORDS ())
    (def SOFT_KEYWORDS ('memo',))


if __name__ == '__main__':
    (import pegen/parser)
    (pegen/parser/simple_parser_main GeneratedParser)
